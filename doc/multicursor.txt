*multicursor.txt*                                             multicursor.nvim

Multiple cursors in Neovim.                                      *multicursor*
                                                            *multicursor.nvim*
                                                                          *mc*

==============================================================================
Table of Contents                              *multicursor-table-of-contents*

1. Features                                             |multicursor-features|
2. Example Configuration                   |multicursor-example-configuration|
 • Selecting Cursors                           |multicursor-selecting-cursors|
 • Changing Cursors                             |multicursor-changing-cursors|
 • Using Cursors                                   |multicursor-using-cursors|
3. Actions                                               |multicursor-actions|
4. API                                                       |multicursor-api|
 • Types                                               |multicursor-api-types|
 • Context Methods                                   |multicursor-api-Context|
 • Cursor Methods                                     |multicursor-api-Cursor|


==============================================================================
Features                                                *multicursor-features*

 • Visual and select modes with char/line/block selections
 • Normal, insert, replace modes
 • Undo/redo
 • Virtualedit
 • Autocompletion
 • Snippet expansion (use `vim.snippet.expand`)
 • Cursor specific registers for searching and yanking
 • Match & split cursor selections with regex
 • Transpose cursor selections
 • Align cursor columns
 • Easily extended with the Cursor API
 • Works with most plugins and remaps


==============================================================================
Example Configuration                      *multicursor-example-configuration*

Basic setup of multicursor.nvim with lazy.nvim, using the default config.
Continue reading for a guide of how to use the default config.

>lua
    {
        "jake-stewart/multicursor.nvim",
        branch = "1.0",
        config = function()
            local mc = require("multicursor-nvim")
            mc.setup()

            local set = vim.keymap.set

            -- Add or skip cursor above/below the main cursor.
            set({"n", "x"}, "<up>", function() mc.lineAddCursor(-1) end)
            set({"n", "x"}, "<down>", function() mc.lineAddCursor(1) end)
            set({"n", "x"}, "<leader><up>", function() mc.lineSkipCursor(-1) end)
            set({"n", "x"}, "<leader><down>", function() mc.lineSkipCursor(1) end)

            -- Add or skip adding a new cursor by matching word/selection
            set({"n", "x"}, "<leader>n", function() mc.matchAddCursor(1) end)
            set({"n", "x"}, "<leader>s", function() mc.matchSkipCursor(1) end)
            set({"n", "x"}, "<leader>N", function() mc.matchAddCursor(-1) end)
            set({"n", "x"}, "<leader>S", function() mc.matchSkipCursor(-1) end)

            -- Add and remove cursors with control + left click.
            set("n", "<c-leftmouse>", mc.handleMouse)
            set("n", "<c-leftdrag>", mc.handleMouseDrag)
            set("n", "<c-leftrelease>", mc.handleMouseRelease)

            -- Disable and enable cursors.
            set({"n", "x"}, "<c-q>", mc.toggleCursor)

            -- Mappings defined in a keymap layer only apply when there are
            -- multiple cursors. This lets you have overlapping mappings.
            mc.addKeymapLayer(function(layerSet)

                -- Select a different cursor as the main one.
                layerSet({"n", "x"}, "<left>", mc.prevCursor)
                layerSet({"n", "x"}, "<right>", mc.nextCursor)

                -- Delete the main cursor.
                layerSet({"n", "x"}, "<leader>x", mc.deleteCursor)

                -- Enable and clear cursors using escape.
                layerSet("n", "<esc>", function()
                    if not mc.cursorsEnabled() then
                        mc.enableCursors()
                    else
                        mc.clearCursors()
                    end
                end)
            end)

            -- Customize how cursors look.
            local hl = vim.api.nvim_set_hl
            hl(0, "MultiCursorCursor", { reverse = true })
            hl(0, "MultiCursorVisual", { link = "Visual" })
            hl(0, "MultiCursorSign", { link = "SignColumn"})
            hl(0, "MultiCursorMatchPreview", { link = "Search" })
            hl(0, "MultiCursorDisabledCursor", { reverse = true })
            hl(0, "MultiCursorDisabledVisual", { link = "Visual" })
            hl(0, "MultiCursorDisabledSign", { link = "SignColumn"})
        end
    }
<


------------------------------------------------------------------------------
Selecting Cursors                              *multicursor-selecting-cursors*

 • You can add cursors above/below the current cursor with `<up>` and `<down>`.
 • You can skip a line with `<leader><up>` or `<leader><down>`.
 • You can match the word/selection under the cursor forwards or backwards
   with `<leader>n` and `<leader>N`.
 • You can skip a match forwards or backwards using `<leader>s` and
   `<leader>S`.
 • You can add and remove cursors using the mouse with `<c-leftmouse>`.


------------------------------------------------------------------------------
Changing Cursors                                *multicursor-changing-cursors*

 • You can rotate through cursors with `<left>` and `<right>`.
 • You can delete the current cursor using `<leader>x`
 • You can disable cursors with `<c-q>`, which means only the main cursor
  moves.
 • When cursors are disabled, you can press `<c-q>` to add a cursor under the
  main cursor.
 • You can press `<esc>` to enable the cursors again.


------------------------------------------------------------------------------
Using Cursors                                      *multicursor-using-cursors*

 • Once you have your cursors, you use vim normally as you would with a
   single cursor.
 • When you want to collapse your cursors back into one, press `<esc>`.


==============================================================================
Actions                                                  *multicursor-actions*

This is a reference to all the example actions created for you to use. If you
want to create your own complex action, see the |multicursor-api|.

 • mc.addCursor                                        |multicursor-addCursor|
 • mc.skipCursor                                      |multicursor-skipCursor|
 • mc.toggleCursor                                  |multicursor-toggleCursor|
 • mc.lineAddCursor                                |multicursor-lineAddCursor|
 • mc.lineSkipCursor                              |multicursor-lineSkipCursor|
 • mc.matchAddCursor                              |multicursor-matchAddCursor|
 • mc.matchSkipCursor                            |multicursor-matchSkipCursor|
 • mc.matchAllAddCursors                      |multicursor-matchAllAddCursors|
 • mc.searchAddCursor                            |multicursor-searchAddCursor|
 • mc.searchSkipCursor                          |multicursor-searchSkipCursor|
 • mc.searchAllAddCursors                    |multicursor-searchAllAddCursors|
 • mc.nextCursor                                      |multicursor-nextCursor|
 • mc.prevCursor                                      |multicursor-prevCursor|
 • mc.firstCursor                                    |multicursor-firstCursor|
 • mc.lastCursor                                      |multicursor-lastCursor|
 • mc.hasCursors                                      |multicursor-hasCursors|
 • mc.deleteCursor                                  |multicursor-deleteCursor|
 • mc.clearCursors                                  |multicursor-clearCursors|
 • mc.handleMouse                                    |multicursor-handleMouse|
 • mc.handleMouseDrag                            |multicursor-handleMouseDrag|
 • mc.handleMouseRelease                      |multicursor-handleMouseRelease|
 • mc.alignCursors                                  |multicursor-alignCursors|
 • mc.splitCursors                                  |multicursor-splitCursors|
 • mc.matchCursors                                  |multicursor-matchCursors|
 • mc.transposeCursors                          |multicursor-transposeCursors|
 • mc.swapCursors                                    |multicursor-swapCursors|
 • mc.insertVisual                                  |multicursor-insertVisual|
 • mc.appendVisual                                  |multicursor-appendVisual|
 • mc.sequenceIncrement                        |multicursor-sequenceIncrement|
 • mc.sequenceDecrement                        |multicursor-sequenceDecrement|
 • mc.addCursorOperator                        |multicursor-addCursorOperator|
 • mc.operator                                          |multicursor-operator|
 • mc.diagnosticAddCursor                    |multicursor-diagnosticAddCursor|
 • mc.diagnosticSkipCursor                  |multicursor-diagnosticSkipCursor|
 • mc.diagnosticMatchCursors              |multicursor-diagnosticMatchCursors|
 • mc.jumpForward                                    |multicursor-jumpForward|
 • mc.jumpBackward                                  |multicursor-jumpBackward|
 • mc.disableCursors                              |multicursor-disableCursors|
 • mc.enableCursors                                |multicursor-enableCursors|
 • mc.cursorsEnabled                              |multicursor-cursorsEnabled|
 • mc.feedkeys                                          |multicursor-feedkeys|
 • mc.addKeymapLayer                              |multicursor-addKeymapLayer|
 • mc.removeKeymapLayer                        |multicursor-removeKeymapLayer|
 • mc.action                                              |multicursor-action|
 • mc.onSafeState                                    |multicursor-onSafeState|


mc.addCursor(motion)                                   *multicursor-addCursor*
    Add a cursor and move only the main cursor using motion.

    Usage example: >lua
        vim.keymap.set("n", "<right>", function()
            mc.addCursor("w")
        end)
<
    Parameters: ~
      • {motion} (`string`) motion to execute on the main cursor leaving a new
        cursor behind


mc.skipCursor(motion)                                 *multicursor-skipCursor*
    Move only the main cursor using motion.

    Usage example: >lua
        vim.keymap.set("n", "<leader><right>", function()
            mc.skipCursor("w")
        end)
<
    Parameters: ~
      • {motion} (`string`) motion to execute on the main cursor without
        adding a new cursor


mc.toggleCursor()                                   *multicursor-toggleCursor*
    Add or remove a cursor under the main cursor. This action disables all
    cursors. You can use `mc.enableCursors` to enable cursors again.

    Usage example: >lua
        vim.keymap.set("n", "<c-q>", mc.toggleCursor)

    See also: ~
      • |multicursor-enableCursors|


mc.lineAddCursor(direction, opts?)                 *multicursor-lineAddCursor*
    Add a cursor above or below the main cursor, skipping empty lines,
    specified by `direction`.

    Usage example: >lua
        vim.keymap.set({"n", "v"}, "<up>", function()
            mc.lineAddCursor(-1)
        end)
        vim.keymap.set({"n", "v"}, "<down>", function()
            mc.lineAddCursor(1)
        end)
<
    Parameters: ~
      • {direction} (`-1 | 1`) when passing in `-1` spawn a cursor in the
        previous line, while `1` spawn in the next line
      • {opts?} (`table?`) options
        • {opts.skipEmpty?} (`boolean?`) Whether lines shorter than cursor
          column should be skipped (default `true`)


mc.lineSkipCursor(direction, opts?)               *multicursor-lineSkipCursor*
    Move only the main cursor up or down a line, skipping empty lines,
    specified by `direction`.

    Usage example: >lua
        vim.keymap.set({"n", "v"}, "<leader><up>", function()
            mc.lineSkipCursor(-1)
        end)
        vim.keymap.set({"n", "v"}, "<leader><down>", function()
            mc.lineSkipCursor(1)
        end)
<
    Parameters: ~
      • {direction} (`-1 | 1`) when passing in `-1` spawn a cursor in the
        previous line, while `1` spawn in the next line
      • {opts?} (`table?`) options
        • {opts.skipEmpty?} (`boolean?`) Whether lines shorter than cursor
          column should be skipped (default `true`)


mc.matchAddCursor(direction)                      *multicursor-matchAddCursor*
    Add a new cursor by matching the current word/selection.

    Usage example: >lua
        vim.keymap.set({"n", "v"}, "<leader>n", function()
            mc.matchAddCursor(1)
        end)
        vim.keymap.set({"n", "v"}, "<leader>N", function()
            mc.matchAddCursor(-1)
        end)
<
    Parameters: ~
      • {direction} (`-1 | 1`) With `1` for clockwise rotation and `-1` for
        anti-clockwise.


mc.matchSkipCursor(direction)                    *multicursor-matchSkipCursor*
    Move only the main cursor by matching the current word/selection.

    Usage example: >lua
        vim.keymap.set({"n", "v"}, "<leader>s", function()
            mc.matchSkipCursor(1)
        end)
        vim.keymap.set({"n", "v"}, "<leader>S", function()
            mc.matchSkipCursor(-1)
        end)
<
    Parameters: ~
      • {direction} (`-1 | 1`) With `1` for clockwise rotation and `-1` for
        anti-clockwise.


mc.matchAllAddCursors()                       *multicursor-matchAllAddCursors*
    Add a cursor for every match of the word/selection under the cursor.

    Usage example: >lua
        vim.keymap.set({"n", "v"}, "<leader>A", mc.matchAllAddCursors)
<

mc.searchAddCursor(direction)                    *multicursor-searchAddCursor*
    Add a cursor and jump to the next/previous search result.

    Usage example: >lua
        vim.keymap.set("n", "<leader>/n", function()
            mc.searchAddCursor(1)
        end)
        vim.keymap.set("n", "<leader>/N", function()
            mc.searchAddCursor(-1)
        end)
<
    Parameters: ~
      • {direction} (`-1 | 1`) With `1` for clockwise rotation and `-1` for
        anti-clockwise.


mc.searchSkipCursor(direction)                  *multicursor-searchSkipCursor*
    Jump to the next/previous search result without adding a cursor.

    Usage example: >lua
        vim.keymap.set("n", "<leader>/s", function()
            mc.searchSkipCursor(-1)
        end)
        vim.keymap.set("n", "<leader>/S", function()
            mc.searchSkipCursor(-1)
        end)
<
    Parameters: ~
      • {direction} (`-1 | 1`) With `1` for clockwise rotation and `-1` for
        anti-clockwise.


mc.searchAllAddCursors()                     *multicursor-searchAllAddCursors*
    Add a cursor to every search result in the buffer.

    Usage example: >lua
        vim.keymap.set("n", "<leader>/A", mc.searchAllAddCursors)
<

mc.nextCursor(wrap?)                                  *multicursor-nextCursor*
    Select the cursor after the main cursor.

    Usage example: >lua
        vim.keymap.set({"n", "v"}, "<left>", mc.nextCursor)
<
    Parameters: ~
      • {wrap?} (`boolean?`) wrap to the start of the file if no cursors are
        found after the main cursor. Defaults to `true`.
<

mc.prevCursor(wrap?)                                  *multicursor-prevCursor*
    Select the cursor before the main cursor.

    Usage example: >lua
        vim.keymap.set({"n", "v"}, "<right>", mc.prevCursor)
<
    Parameters: ~
      • {wrap?} (`boolean?`) wrap to the end of the file if no cursors are
        found before the main cursor. Defaults to `true`.

mc.firstCursor()                                     *multicursor-firstCursor*
    Select the first cursor.

    Usage example: >lua
        vim.keymap.set({"n", "v"}, "H", mc.firstCursor)
<

mc.lastCursor()                                       *multicursor-lastCursor*
    Select the last cursor.

    Usage example: >lua
        vim.keymap.set({"n", "v"}, "L", mc.lastCursor)
<

mc.hasCursors()                                       *multicursor-hasCursors*
    Returns whether multiple cursors exist.

    Usage example: >lua
        vim.keymap.set({ "n", "v" }, "<esc>", function()
            if mc.hasCursors() then
                mc.clearCursors()
            end
        end)
<
    Return: ~
      • (`boolean`) true if there are more than 1 cursor.


mc.deleteCursor()                                   *multicursor-deleteCursor*
    Delete the main cursor. The closest cursor becomes the new main cursor.

    Usage example: >lua
        vim.keymap.set({"n", "v"}, "<leader>x", mc.deleteCursor)
<

mc.clearCursors()                                   *multicursor-clearCursors*
    Clear all cursors except main cursor.

    Usage example: >lua
        vim.keymap.set({ "n", "v" }, "<esc>", function()
            if mc.hasCursors() then
                mc.clearCursors()
            end
        end)
<

mc.handleMouse()                                     *multicursor-handleMouse*
    Use in a mouse mapping to handle adding and removing cursors with mouse
    click.

    Usage example: >lua
        vim.keymap.set("n", "<c-leftmouse>", mc.handleMouse)


mc.handleMouseDrag()                             *multicursor-handleMouseDrag*
    Use in a mouse mapping to handle adding and removing cursors with mouse
    drag.

    Usage example: >lua
        vim.keymap.set("n", "<c-leftdrag>", mc.handleMouseDrag)
<

mc.handleMouseRelease()                       *multicursor-handleMouseRelease*
    Use in a mouse mapping to improve mouse support when dragging with a
    modifier after having already clicked without it.

    Usage example: >lua
        vim.keymap.set("n", "<c-leftrelease>", mc.handleMouseRelease)
<

mc.alignCursors()                                   *multicursor-alignCursors*
    Align columns of cursors on multiple lines.

    Usage example: >lua
        vim.keymap.set("n", "<leader>a", mc.alignCursors)
<

mc.splitCursors()                                   *multicursor-splitCursors*
    Interactively ask for a regex separator, split every visual selections
    with the regex separator. To be used in visual/select mode only.

    For example, visually selecting "ab,cd,ef,gh" and splitting with "," will
    create four cursors, each selecting a group of letters.

    Usage example: >lua
        vim.keymap.set("v", "S", mc.splitCursors)
<

mc.matchCursors()                                   *multicursor-matchCursors*
    Interactively ask for a pattern, add a cursor for each match of this
    pattern over every visual selections.
    To be used in visual/select mode only.

    For example, visually selecting "foo bar foo" and matching with "foo" will
    create two cursors, one on each "foo".

    Usage example: >lua
        vim.keymap.set("v", "M", mc.matchCursors)


mc.transposeCursors(direction)                  *multicursor-transposeCursors*
    Rotate the contents of each visual selection for each cursor.

    Usage example: >lua
        vim.keymap.set("v", "<leader>t", function()
            mc.transposeCursors(1)
        end)
        vim.keymap.set("v", "<leader>T", function()
            mc.transposeCursors(-1)
        end)
<
    Parameters: ~
      • {direction} (`-1 | 1`) With `1` for clockwise rotation and `-1` for
        anti-clockwise.

    See also: ~
      • |multicursor-swapCursors|

mc.swapCursors(direction)                            *multicursor-swapCursors*
    Swaps the visual selection of the current cursor with that of the
    next/previous cursor, specified by `direction`.

    Usage example: >lua
        vim.keymap.set("v", "<leader>h", function()
            mc.swapCursors(-1)
        end)
        vim.keymap.set("v", "<leader>l", function()
            mc.swapCursors(1)
        end)
<
    Parameters: ~
      • {direction} (`-1 | 1`) With `1` for clockwise rotation and `-1` for
        anti-clockwise.
      • {wrap?} (`boolean?`) Whether the search for the target cursor wrap
        if not found.

    See also: ~
      • |multicursor-transposeCursors|


mc.insertVisual()                                   *multicursor-insertVisual*
    Create a cursor for each line of the visual selection, and enter insert
    mode with `I`.

    Usage example: >lua
        vim.keymap.set("v", "I", mc.insertVisual)
<

mc.appendVisual()                                   *multicursor-appendVisual*
    Create a cursor for each line of the visual selection, and enter insert
    mode with `A`.

    Usage example: >lua
        vim.keymap.set("v", "A", mc.appendVisual)
<

mc.sequenceIncrement()                         *multicursor-sequenceIncrement*
    Behaves like |g_CTRL-a|, except all lines of all cursors are treated as
    one sequence.

    Usage example: >lua
        vim.keymap.set({"x", "n"}, "g<c-a>", mc.sequenceIncrement)
<

mc.sequenceDecrement()                         *multicursor-sequenceDecrement*
    Behaves like |g_CTRL-x|, except all lines of all cursors are treated as
    one sequence.

    Usage example: >lua
        vim.keymap.set({"x", "n"}, "g<c-x>", mc.sequenceDecrement)
<

mc.addCursorOperator()                         *multicursor-addCursorOperator*
    Takes a motion and adds a cursor for every lines.

    For example, if it is mapped to `ga`, then typing `gaip` will add a cursor
    for every line in the current paragraph.

    Usage example: >lua
        vim.keymap.set("n", "ga", mc.addCursorOperator)
<

mc.operator(opts?)                                      *multicursor-operator*
    Adds a cursor for every match found in a region. The text to match is
    given by a motion, and the region is given by a second motion.

    For example, if mapped to `<leader>m` then `<leader>miwap` will find every
    match within the paragraph of the text contained within `iw`.
    If called from visual mode, the selection becomes the first motion's
    target text.

    Usage example: >lua
        vim.keymap.set({ "x", "n" }, "<leader>m", mc.operator)
<
    Parameters: ~
      • {opts?} (`table?`) options
        • {opts.pattern?} (`string?`) A predefined pattern to skip having to
          input the first motion.
        • {opts.motion?} (`string?`) A predefined motion to skip having to
          input the first motion.
        • {opts.visual?} (`boolean?`) Whether the cursors should visually
          select their matches.
        • {opts.wordBoundary?} (`boolean?`) Whether the pattern should
          consider word boundaries when matching.

mc.diagnosticAddCursor(direction)            *multicursor-diagnosticAddCursor*
    Add a cursor at the next diagnostic found in `direction`.

    Usage example: >lua
        vim.keymap.set({"n", "x"}, "]d", function()
            mc.diagnosticAddCursor(1)
        end)
        vim.keymap.set({"n", "x"}, "[d", function()
            mc.diagnosticAddCursor(-1)
        end)
<
    Parameters: ~
      • {direction} (`-1 | 1`) With `1` for clockwise rotation and `-1` for
        anti-clockwise.

    See also: ~
      • |multicursor-diagnosticSkipCursor|


mc.diagnosticSkipCursor(direction)          *multicursor-diagnosticSkipCursor*
    Skips to the next diagnostic found in `direction`.

    Usage example: >lua
        vim.keymap.set({"n", "x"}, "]d", function()
            mc.diagnosticAddCursor(1)
        end)
        vim.keymap.set({"n", "x"}, "[d", function()
            mc.diagnosticAddCursor(-1)
        end)
<
    Parameters: ~
      • {direction} (`-1 | 1`) With `1` for clockwise rotation and `-1` for
        anti-clockwise.

    See also: ~
      • |multicursor-diagnosticAddCursor|

mc.diagnosticMatchCursors(opts?)          *multicursor-diagnosticMatchCursors*
    Adds a cursor for every diagnostic found in the range provided by a
    motion.

    Usage example: >lua
        vim.keymap.set({"n", "x"}, "md", function()
            mc.diagnosticMatchCursors({ severity = vim.diagnostic.severity.ERROR })
        end)
<
    Parameters: ~
      • {opts?} |vim.diagnostic.GetOpts|


mc.jumpForward()                                     *multicursor-jumpForward*
    This action is automatically mapped to `<c-i>` unless a mapping already
    exists. It behaves identically to `<c-i>` except it syncs up the cursors.

    Usage example: >lua
        vim.keymap.set({"n", "x"}, "<c-i>", mc.jumpForward)
<

mc.jumpBackward()                                   *multicursor-jumpBackward*
    This action is automatically mapped to `<c-o>` unless a mapping already
    exists. It behaves identically to `<c-o>` except it syncs up the cursors.

    Usage example: >lua
        vim.keymap.set({"n", "x"}, "<c-o>", mc.jumpBackward)
<

mc.disableCursors()                               *multicursor-disableCursors*
    Locks the cursors from moving. This is useful for repositioning main
    cursor for adding more cursors.

    Usage example: >lua
        vim.keymap.set({"n", "v"}, "<c-q>", mc.disableCursors)
<
    See also: ~
      • |multicursor-enableCursors|


mc.enableCursors()                                 *multicursor-enableCursors*
    Unlocks disabled cursors, currently active cursors will be discarded.

    Usage example: >lua
        vim.keymap.set({"n", "v"}, "<c-q>", mc.enableCursors)
<
    See also: ~
      • |multicursor-disableCursors|


mc.cursorsEnabled()                               *multicursor-cursorsEnabled*
    Returns whether the cursors are locked from moving.

    Usage example: >lua
        if not mc.cursorsEnabled() then
            mc.enableCursors()
        end
<
    Return: ~
      • (`boolean`) true if cursors are locked

    See also: ~
      • |multicursor-disableCursors|
      • |multicursor-enableCursors|


mc.feedkeys({keys}, {opts?})                            *multicursor-feedkeys*
    Use instead of `vim.fn.feedkeys()` or `vim.api.nvim_feedkeys()` in
    multicursor mappings to avoid bugs.

    Parameters: ~
      • {keys} (`string`) string representing a command
      • {opts?} (`table?`) options
        • {opts.remap?} (`boolean?`) if true use remapped keys
        • {opts.keycodes?} (`boolean?`) if true translate keycodes


mc.addKeymapLayer(callback)                       *multicursor-addKeymapLayer*
    Registers a keymap layer callback.
    It will be called when a buffer has cursors, any mappings set with the
    provided function (similar to `vim.keymap.set`) will be automatically
    removed once multicursor ends.

    Usage example: >lua
        mc.addKeymapLayer(function(layerSet)
            layerSet("n", "x", mc.deleteCursor)
        end)
<
    Parameters: ~
      • {callback} (`function`) callback function which sets layer mappings.
        Same arguments as |vim.keymap.set()|.

    See also: ~
      • |vim.keymap.set()|
      • |multicursor-removeKeymapLayer|


mc.removeKeymapLayer(callback)                 *multicursor-removeKeymapLayer*
    Removes a previously added keymap layer callback.

    Parameters: ~
      • {callback} (`function`) the callback to be removed.

    See also: ~
      • |multicursor-removeKeymapLayer|


mc.action(func)                                           *multicursor-action*
    Perform a complex action using the |multicursor-api|.

    Usage example: >lua
        mc.action(function(ctx)
            local cursors = ctx:getCursors()
        end)
<
    Parameters: ~
      • {func} (`function`) function to execute on cursors.
        • {ctx} (`CursorContext`) allows to query for cursors.

    See also: ~
      • |multicursor-api-Context|
      • |multicursor-api|


mc.onSafeState(func, opts?)                          *multicursor-onSafeState*
    Execute callback upon reaching multicursor safestate.

    Usage example: >lua
        mc.onSafeState(function(details)
            if details.wasMode ~= vim.fn.mode() then
                print("mode changed!")
            end
        end)
<
    Parameters: ~
      • {func} (`function`) function to execute on safe state.
      • {opts?} (`table?`) options
        • {opts.once?} (`boolean?`) only call func for a single safestate.


==============================================================================
API                                                          *multicursor-api*

All of the provided actions are implemented using the Cursor API, which is
accessible for writing your own complex multi-cursor logic.

You can use the Cursor API by calling |multicursor-action| with a callback,
like so:

>lua
    mc.action(function(ctx)
        local cursors = ctx:getCursors()
    end)
<

The `ctx` is a `CursorContext` which lets you query for cursors. In the
snippet, we simply called `getCursors()` to get a list of all our cursors.

In the next snippet, we will instead call `firstCursor()` to get only the
highest cursor in the document. Once we have our cursor, we can interact with
it.

>lua
    mc.action(function(ctx)
        local cursor = ctx:firstCursor()
        vim.print(cursor:getLine())
        cursor:feedkeys("ihello world")
    end)
>

And that's it. See the |multicursor-api-Context| and |multicursor-api-Cursor|
sections for an API overview. Also look at the `examples.lua` file in the
GitHub repo for example usage.

See also: ~
  • |multicursor-action|
  • |multicursor-api-Context|
  • |multicursor-api-Cursor|


------------------------------------------------------------------------------
Types                                                  *multicursor-api-types*

CursorQuery                                    *multicursor-types-CursorQuery*
>lua
    --- @alias CursorQuery {disableCursors?: boolean, enableCursors?: boolean}
<
    Fields: ~
      • disableCursors (`boolean?`) if true return disable cursors
      • enableCursors (`boolean?`) if true return enabled cursors


Pos                                                    *multicursor-types-Pos*
>lua
    --- @alias Pos [integer, integer, integer]
<
    Fields: ~
      • 1 (`integer`) 1-indexed line
      • 2 (`integer`) 1-indexed col
      • 3 (`integer`) offset


SimplePos                                        *multicursor-types-SimplePos*
>lua
    --- @alias SimplePos [integer, integer]
<
    Fields: ~
      • 1 (`integer`) 1-indexed line
      • 2 (`integer`) 1-indexed col


------------------------------------------------------------------------------
Context Methods                                      *multicursor-api-Context*

 • setCursorsEnabled                       |multicursor-ctx-setCursorsEnabled|
 • getCursors                                     |multicursor-ctx-getCursors|
 • addCursor                                       |multicursor-ctx-addCursor|
 • forEachCursor                               |multicursor-ctx-forEachCursor|
 • mapCursors                                     |multicursor-ctx-mapCursors|
 • findLastCursor                             |multicursor-ctx-findLastCursor|
 • findCursor                                     |multicursor-ctx-findCursor|
 • nextCursor                                     |multicursor-ctx-nextCursor|
 • prevCursor                                     |multicursor-ctx-prevCursor|
 • seekCursor                                     |multicursor-ctx-seekCursor|
 • seekBoundaryCursor                     |multicursor-ctx-seekBoundaryCursor|
 • nearestCursor                               |multicursor-ctx-nearestCursor|
 • getCursorAtPos                             |multicursor-ctx-getCursorAtPos|
 • overlappedCursor                         |multicursor-ctx-overlappedCursor|
 • mainCursor                                     |multicursor-ctx-mainCursor|
 • firstCursor                                   |multicursor-ctx-firstCursor|
 • lastCursor                                     |multicursor-ctx-lastCursor|
 • cursorsEnabled                             |multicursor-ctx-cursorsEnabled|
 • hasCursors                                     |multicursor-ctx-hasCursors|
 • numCursors                                     |multicursor-ctx-numCursors|
 • numEnabledCursors                       |multicursor-ctx-numEnabledCursors|
 • numDisabledCursors                     |multicursor-ctx-numDisabledCursors|
 • clear                                               |multicursor-ctx-clear|


ctx:setCursorsEnabled(value)               *multicursor-ctx-setCursorsEnabled*
    Enables or disables all cursors.

    Parameters: ~
      • {value} (`boolean`)


ctx:getCursors(opts?)                             *multicursor-ctx-getCursors*
    Returns a list of cursors, sorted by their position.

    Parameters: ~
      • {opts?} (`CursorQuery?`) type of cursors to get.

    Return: ~
      • (`Cursor[]`) table of `Cursor` objects.

    See also: ~
      • |multicursor-api-Cursor|
      • |multicursor-types-CursorQuery|


ctx:addCursor()                                    *multicursor-ctx-addCursor*
    Creates a new virtual cursor, returning it.

    Return: ~
      • (`Cursor`) the new cursor.

    See also: ~
      • |multicursor-api-Cursor|


ctx:forEachCursor(callback, opts?)             *multicursor-ctx-forEachCursor*
    Util which executes callback for each cursor, sorted by their position.

    Parameters: ~
      • {callback} (`function`) a function that will be executed on each
        cursor.
      • {opts?} (`CursorQuery?`) type of cursor iterate over.

    See also: ~
      • |multicursor-api-Cursor|
      • |multicursor-types-CursorQuery|


ctx:mapCursors(callback, opts?)                   *multicursor-ctx-mapCursors*
    Util method which maps each cursor to a value.

    Parameters: ~
      • {callback} (`function`) a function that will be executed on each
        cursor.
      • {opts?} (`CursorQuery?`) type of cursor to map over.

    Return: ~
      • (`Cursor[]`) table with mapped results.

    See also: ~
      • |multicursor-api-Cursor|
      • |multicursor-types-CursorQuery|


ctx:findLastCursor(predicate, opts?)          *multicursor-ctx-findLastCursor*
    Util method which returns the last cursor matching the predicate.

    Parameters: ~
      • {predicate} (`function`)
      • {opts?} (`CursorQuery?`) type of cursor to search for.

    Return: ~
      • (`Cursor | nil`) returns the last cursor matching predicate or nil if
        no cursors were found.

    See also: ~
      • |multicursor-api-Cursor|
      • |multicursor-types-CursorQuery|


ctx:findCursor(predicate, opts?)                  *multicursor-ctx-findCursor*
    Util method which returns the first cursor matching the predicate.

    Parameters: ~
      • {predicate} (`function`)
      • {opts?} (`CursorQuery?`) type of cursor to search for.

    Return: ~
      • (`Cursor | nil`) returns the first cursor matching predicate or nil if
        no cursors were found.

    See also: ~
      • |multicursor-api-Cursor|
      • |multicursor-types-CursorQuery|


ctx:nextCursor(pos, opts?)                        *multicursor-ctx-nextCursor*
    Returns the closest cursor which appears AFTER pos. A cursor exactly at
    pos will not be returned. It does not wrap, so if none are found, then nil
    is returned. If you wish to wrap, use:
    `ctx:nextCursor(...) or ctx:firstCursor(...)`

    Parameters: ~
      • {pos} (`SimplePos | Pos`) position to search from.
      • {opts?} (`CursorQuery?`) type of cursor to search for.

    Return: ~
      • (`Cursor | nil`) returns the closest cursor after the pos or nil if
        none are found.

    See also: ~
      • |multicursor-api-Cursor|
      • |multicursor-types-CursorQuery|
      • |multicursor-types-SimplePos|
      • |multicursor-types-Pos|


ctx:prevCursor(pos, opts?)                        *multicursor-ctx-prevCursor*
    Returns the closest cursor which appears BEFORE pos. A cursor exactly at
    pos will not be returned. It does not wrap, so if none are found, then nil
    is returned. If you wish to wrap, use:
    `ctx:prevCursor(...) or ctx:lastCursor(...)`

    Parameters: ~
      • {pos} (`SimplePos | Pos`) position to search from.
      • {opts?} (`CursorQuery?`) type of cursor to search for.

    Return: ~
      • (`Cursor | nil`) returns the closest cursor before the pos or nil if
        none are found.

    See also: ~
      • |multicursor-api-Cursor|
      • |multicursor-types-CursorQuery|
      • |multicursor-types-SimplePos|
      • |multicursor-types-Pos|


ctx:seekCursor(pos, direction, wrap?, opts?)      *multicursor-ctx-seekCursor*
    Returns the closest cursor in the specified `direction`, which can
    optionally wrap.

    Parameters: ~
      • {pos} (`SimplePos | Pos`) position to search from.
      • {direction} (`-1 | 1`) With `1` for clockwise rotation and `-1` for
        anti-clockwise.
      • {wrap?} (`boolean?`) Whether the seach should wrap around the
        document.
      • {opts?} (`CursorQuery?`) type of cursor to search for.

    Return: ~
      • (`Cursor | nil`) the matched cursor or nil if none are found.

    See also: ~
      • |multicursor-api-Cursor|
      • |multicursor-types-CursorQuery|
      • |multicursor-types-SimplePos|
      • |multicursor-types-Pos|


ctx:seekBoundaryCursor(direction, opts?)  *multicursor-ctx-seekBoundaryCursor*
    Returns the first/last cursor, specified by `direction`.

    Parameters: ~
      • {direction} (`-1 | 1`) With `-1` for the first and `1` for the last
        cursor.
      • {wrap?} (`boolean?`) Whether the seach should wrap around the
        document.
      • {opts?} (`CursorQuery?`) type of cursor to search for.

    Return: ~
      • (`Cursor | nil`) the matched cursor or nil if none are found.

    See also: ~
      • |multicursor-api-Cursor|
      • |multicursor-types-CursorQuery|
      • |multicursor-types-SimplePos|
      • |multicursor-types-Pos|


ctx:nearestCursor(pos, opts?)                  *multicursor-ctx-nearestCursor*
    Returns the nearest cursor to pos, and accepts a cursor exactly at pos.

    Parameters: ~
      • {pos} (`SimplePos | Pos`) position to search from.
      • {opts?} (`CursorQuery?`) type of cursor to search for.

    Return: ~
      • (`Cursor | nil`) returns closest cursor or nil if none found.

    See also: ~
      • |multicursor-api-Cursor|
      • |multicursor-types-CursorQuery|
      • |multicursor-types-SimplePos|
      • |multicursor-types-Pos|


ctx:getCursorAtPos(pos, opts?)                *multicursor-ctx-getCursorAtPos*
    Returns the exact cursor at pos.

    Parameters: ~
      • {pos} (`SimplePos | Pos`) position to search at.
      • {opts?} (`CursorQuery?`) type of cursor to search for.

    Return: ~
      • (`Cursor | nil`) returns the cursor or nil if there are no cursors at
        position.

    See also: ~
      • |multicursor-api-Cursor|
      • |multicursor-types-CursorQuery|
      • |multicursor-types-SimplePos|
      • |multicursor-types-Pos|


ctx:overlappedCursor()                      *multicursor-ctx-overlappedCursor*
    Returns the cursor under the main cursor.

    Return: ~
      • (`Cursor | nil`) returns cursor under the main cursor.

    See also: ~
      • |multicursor-api-Cursor|


ctx:mainCursor()                                  *multicursor-ctx-mainCursor*
    Returns the main cursor.

    Return: ~
      • (`Cursor`) return the main cursor.

    See also: ~
      • |multicursor-api-Cursor|


ctx:firstCursor(opts?)                           *multicursor-ctx-firstCursor*
    Returns the cursor closest to the start of the document.

    Parameters: ~
      • {opts?} (`CursorQuery?`) type of cursor to search for.

    Return: ~
      • (`Cursor | nil`) returns the first cursor in the document or nil if
        there are none.

    See also: ~
      • |multicursor-api-Cursor|
      • |multicursor-types-CursorQuery|


ctx:lastCursor(opts?)                             *multicursor-ctx-lastCursor*
    Returns the cursor closest to the end of the document.

    Parameters: ~
      • {opts?} (`CursorQuery?`) type of cursor to search for.

    Return: ~
      • (`Cursor | nil`) returns the last cursor in the document or nil if
        there are none.

    See also: ~
      • |multicursor-api-Cursor|
      • |multicursor-types-CursorQuery|


ctx:cursorsEnabled()                          *multicursor-ctx-cursorsEnabled*
    Returns whether all cursors are enabled.

    Return: ~
      • (`boolean`) true if ALL cursors are enabled.


ctx:hasCursors()                                  *multicursor-ctx-hasCursors*
    Returns whether there are virtual cursors.

    Return: ~
      • (`boolean`) true if there are any virtual cursors.


ctx:numCursors()                                  *multicursor-ctx-numCursors*
    Returns the total number of cursors.
    There is always at least one cursor (the main cursor).

    Return: ~
      • (`integer`) the number of cursors.


ctx:numEnabledCursors()                    *multicursor-ctx-numEnabledCursors*
    Returns number of enabled cursors.
    There is always at least one enabled cursor (the main cursor).

    Return: ~
      • (`integer`) the number of enabled cursors.


ctx:numDisabledCursors()                 *multicursor-ctx-numDisabledCursors*
    Returns the number of disabled cursors.

    Return: ~
      • (`integer`) the number of disabled cursors.


ctx:clear()                                            *multicursor-ctx-clear*
    Removes all cursors.


------------------------------------------------------------------------------
Cursor Methods                                        *multicursor-api-Cursor*

 • Cursor:line                                       |multicursor-cursor-line|
 • Cursor:col                                         |multicursor-cursor-col|
 • Cursor:getLine                                 |multicursor-cursor-getLine|
 • Cursor:delete                                   |multicursor-cursor-delete|
 • Cursor:overlappedCursor               |multicursor-cursor-overlappedCursor|
 • Cursor:select                                   |multicursor-cursor-select|
 • Cursor:isMainCursor                       |multicursor-cursor-isMainCursor|
 • Cursor:atVisualStart                     |multicursor-cursor-atVisualStart|
 • Cursor:splitVisualLines               |multicursor-cursor-splitVisualLines|
 • Cursor:getPos                                   |multicursor-Cursor-getPos|
 • Cursor:setPos                                   |multicursor-Cursor-setPos|
 • Cursor:setVisualAnchor                 |multicursor-Cursor-setVisualAnchor|
 • Cursor:getVisualAnchor                 |multicursor-Cursor-getVisualAnchor|
 • Cursor:setRedoChangePos               |multicursor-cursor-setRedoChangePos|
 • Cursor:registerUndo                       |multicursor-cursor-registerUndo|
 • Cursor:clone                                     |multicursor-cursor-clone|
 • Cursor:getVisualLines                   |multicursor-Cursor-getVisualLines|
 • Cursor:setVisualLines                   |multicursor-Cursor-setVisualLines|
 • Cursor:getFullVisualLines           |multicursor-Cursor-getFullVisualLines|
 • Cursor:getVisual                             |multicursor-cursor-getVisual|
 • Cursor:mode                                       |multicursor-cursor-mode|
 • Cursor:setMode                                 |multicursor-cursor-setMode|
 • Cursor:disable                                 |multicursor-cursor-disable|
 • Cursor:enable                                   |multicursor-cursor-enable|
 • Cursor:feedkeys                               |multicursor-cursor-feedkeys|
 • Cursor:perform                                 |multicursor-cursor-perform|
 • Cursor:getCursorWord                     |multicursor-cursor-getCursorWord|
 • Cursor:setSearch                             |multicursor-cursor-setSearch|
 • Cursor:setVisual                             |multicursor-cursor-setVisual|
 • Cursor:inVisualMode                       |multicursor-cursor-inVisualMode|
 • Cursor:inSelectMode                       |multicursor-cursor-inSelectMode|
 • Cursor:hasSelection                       |multicursor-cursor-hasSelection|


Cursor:line()                                        *multicursor-cursor-line*
    Returns this cursors current line number, 1 indexed.

    Return: ~
      • (`integer`) line number.


Cursor:col()                                          *multicursor-cursor-col*
    Returns this cursors current column number, 1 indexed.

    Return: ~
      • (`integer`) column number.


Cursor:getLine()                                  *multicursor-cursor-getLine*
    Returns the full line text of where this cursor is located.

    Return: ~
      • (`string`) line text.


Cursor:delete()                                    *multicursor-cursor-delete*
    Deletes this cursor. If this is the main cursor then the closest cursor to
    it is set as the new main cursor. If this is the last remaining cursor, a
    new cursor is created at its position.


Cursor:overlappedCursor()                *multicursor-cursor-overlappedCursor*
    Returns the disabled cursor underneath this one, if it exists.

    Return: ~
      • (`Cursor | nil`) disabled `Cursor` or nil if there isn't any.

    See also: ~
      • |multicursor-api-Cursor|


Cursor:select()                                    *multicursor-cursor-select*
    Sets this cursor as the main cursor.

    Return: ~
      • (`self`)


Cursor:isMainCursor()                        *multicursor-cursor-isMainCursor*
    Returns whether this cursor is the main cursor.

    Return: ~
      • (`boolean`) true if it is the main cursor.


Cursor:atVisualStart()                      *multicursor-cursor-atVisualStart*
    A cursor can either be at the start or end of a visual selection. For
    example, if you select lines 10-20, your cursor can either be on line 10
    (start) or 20 (end). this method returns true when at the start.

    Return: ~
      • (`boolean`) true if the cursor is at the beginning of its selection.


Cursor:splitVisualLines()                *multicursor-cursor-splitVisualLines*
    For each line of the cursor's visual selection, a new cursor is created,
    visually selecting only the single line. This method deletes the original
    cursor.

    Return: ~
      • (`Cursor[]`) table of Cursors


Cursor:getPos()                                    *multicursor-Cursor-getPos*
    Returns the position of a cursor.

    Return: ~
      • (`Pos`) position of the cursor.

    See also: ~
      • |multicursor-types-Pos|


Cursor:setPos(pos)                                 *multicursor-Cursor-setPos*
    Sets the position of the cursor.

    Parameters: ~
      • {pos} (`SimplePos | Pos`) new position of the cursor.

    Return: ~
      • (`self`)

    See also: ~
      • |multicursor-types-SimplePos|
      • |multicursor-types-Pos|


Cursor:setVisualAnchor(pos)               *multicursor-Cursor-setVisualAnchor*
    Sets the position of the visual anchor equivalent of `setpos()` on `'v'`
    for a cursor.

    Parameters: ~
      • {pos} (`SimplePos | Pos`) new position of the anchor.

    Return: ~
      • (`self`)

    See also: ~
      • |multicursor-types-SimplePos|
      • |multicursor-types-Pos|
      • |Visual|
      • |setpos()|


Cursor:getVisualAnchor()                  *multicursor-Cursor-getVisualAnchor*
    Returns the position of cursor's visual anchor same as `getpos('v')`.

    Return: ~
      • (`Pos`) position of the anchor.

    See also: ~
      • |multicursor-types-SimplePos|
      • |multicursor-types-Pos|
      • |Visual|
      • |getpos()|


Cursor:setRedoChangePos(pos)             *multicursor-cursor-setRedoChangePos*
    Sets the position of the redo position marker.

    Parameters: ~
      • {pos} (`Pos`) new position cursor should have when redoing.

    See also: ~
      • |multicursor-types-SimplePos|
      • |multicursor-types-Pos|


Cursor:setUndoChangePos(pos)             *multicursor-cursor-setUndoChangePos*
    Sets the position of the undo position marker.

    Parameters: ~
      • {pos} (`Pos`) new position cursor should have when undoing.

    See also: ~
      • |multicursor-types-SimplePos|
      • |multicursor-types-Pos|


Cursor:registerUndo()                        *multicursor-cursor-registerUndo*
    Registers this cursor so that its original position is restored upon undo.


Cursor:clone()                                      *multicursor-cursor-clone*
    Returns a new cursor with the same position, registers, visual selection,
    and mode as this cursor.

    Return: ~
      • (`Cursor`) the new cursor.

    See also: ~
      • |multicursor-api-Cursor|


Cursor:setVisualLines(lines)               *multicursor-Cursor-setVisualLines*
    Replace only the text contained in each line of the visual selection.
    If lines is longer than the visual selection, new lines are created.
    For visual block mode, the number of lines has to match the size of the
    visual selection.

    Parameters: ~
      • {lines} (`string[]`) lines to replace visual selection with

    Return: ~
      • (`self`)

    See also: ~
      • |multicursor-Cursor-getVisualLines|


Cursor:getVisualLines()                    *multicursor-Cursor-getVisualLines*
    Returns only the text contained in each line of the visual selection.

    Return: ~
      • (`string[]`) the lines.

    See also: ~
      • |multicursor-Cursor-setVisualLines|
      • |multicursor-Cursor-setFullVisualLines|


Cursor:getFullVisualLines()            *multicursor-Cursor-getFullVisualLines*
    Returns the full line for each line of the visual selection.

    Return: ~
      • (`string[]`) the lines.

    See also: ~
      • |multicursor-Cursor-getVisualLines|

Cursor:getVisual()                              *multicursor-cursor-getVisual*
    Returns start and end positions of visual selection start position is
    before or equal to end position.

    Return: ~
      • (`Pos`) starting position of the visual selection.
      • (`Pos`) ending position of the visual selection.

    See also: ~
      • |multicursor-types-Pos|


Cursor:mode()                                        *multicursor-cursor-mode*
    Returns this cursor's current mode. It should only ever be in normal,
    visual, or select modes.

    Return: ~
      • (`string`) mode of the cursor
        One of: "n" | "v" | "V" | <c-v> | "s" | "S" | <c-s>

    See also: ~
      • |mode()|


Cursor:setMode(mode)                              *multicursor-cursor-setMode*
    Sets this cursor's mode. It should only ever be in normal, visual, or
    select modes.

    Parameters: ~
      • {mode} (`string`) new mode of the cursor
        One of: "n" | "v" | "V" | <c-v> | "s" | "S" | <c-s>

    Return: ~
      • (`self`)

    See also: ~
      • |mode()|


Cursor:disable()                                  *multicursor-cursor-disable*
    Disable the cursor.


Cursor:enable()                                    *multicursor-cursor-enable*
    Enable the cursor.


Cursor:feedkeys(keys, opts?)                     *multicursor-cursor-feedkeys*
    Makes the cursor perform a command/commands.

    For example, `cursor:feedkeys('dw')` will delete a word. By default, keys
    are not remapped and keycodes are not parsed.

    Parameters: ~
      • {keys} (`string`) string representing a command
      • {opts?} (`table?`) options
        • {opts.remap?} (`boolean?`) if true use remapped keys
        • {opts.keycodes?} (`boolean?`) if true translate keycodes


Cursor:perform(callback)                          *multicursor-cursor-perform*
    Activates this cursor by setting its registers, visual selection, mode,
    position, etc. Then, it calls the provided callback where you can perform
    some lower level operations. Once the callback is finished, the new cursor
    state is read and the previously selected cursor is restored.

    Parameters: ~
      • {callback} (`function`) function to execute on a cursor
        • {cursor} (`Cursor`)

    See also: ~
      • |multicursor-api-cursor|


Cursor:getCursorWord()                      *multicursor-cursor-getCursorWord*
    Return the <cword> for this cursor.

    Return: ~
      • (`string`) current word under cursor.

    See also: ~
      • |<cword>|


Cursor:setSearch(search)                        *multicursor-cursor-setSearch*
    Set the search register of this cursor.

    Parameters: ~
      • {search} (`string`) new content of the register.

    See also: ~
      • |"/|


Cursor:setVisual(visualStart, visualEnd)        *multicursor-cursor-setVisual*
    Sets the visual selection and sets the cursor position to `visualEnd`.

    Parameters: ~
      • {visualStart} (`SimplePos | Pos`) start position of the visual
        selection.
      • {visualEnd} (`SimplePos | Pos`) end position of the visual selection.

    See also: ~
      • |multicursor-types-SimplePos|
      • |multicursor-types-Pos|
      • |Visual|


Cursor:inVisualMode()                        *multicursor-cursor-inVisualMode*
    Returns true if cursor is in visual mode.

    Return: ~
      • (`boolean`) true if cursor is in visual mode.

    See also: ~
      • |Visual|


Cursor:inSelectMode()                        *multicursor-cursor-inSelectMode*
    Returns true if cursor is in select mode.

    Return: ~
      • (`boolean`) true if cursor is in select mode.

    See also: ~
      • |Select|


Cursor:hasSelection()                        *multicursor-cursor-hasSelection*
    Returns true if cursor is in visual or select mode.

    Return: ~
      • (`boolean`) true if either in select or visual mode

    See also: ~
      • |Visual|
      • |Select|


Thanks to Cathyprime for writing these help pages.

vim:tw=78:ts=8:noet:ft=help:norl:
